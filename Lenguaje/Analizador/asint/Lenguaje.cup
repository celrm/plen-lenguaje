package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexico;
import alex.UnidadLexica;
import errors.GestionErrores;
import alex.TV;
import ast.Op;
import ast.Dec;
import ast.ASExp;
import ast.ASIns;

scan with {: return getScanner().next_token(); :};
action code {:
   private ASExp as = new ASExp();
   private ASIns is = new ASIns();
:};
parser code {: 
   private GestionErrores errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErrores();
   AnalizadorLexico alex = (AnalizadorLexico)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal    TV  Id, Entero, Import, From, Const, Arr, Ent, 
                        Bul, Car, Data, Function, Type, Return, Main, If, 
                        Else, While, For, Punto, Si, No, Kut, Caracter, 
                        Asign, Distinto, Igual, Or, And, Menor, Meq, 
                        Mayor, Maq, Not, Suma, Guion, Mul, Div, Mod,
                        Indice, Acceso, PA, PC, CA, CC, LA, LC, Coma, 
                        DosPts, Backslash
                        ;

non terminal    PROG, IMPORTBL, DECBL, DEC_VAR, DEC_DEFREG, DEC_REG,
                CPARAMS, DENTRO_REG, DEC_FUN, PARAMS, DENTRO, DEC_TYPE,
                MAINBL,EXPR, EXPFUN, EXPLISTA, LISTADENTRO, VALUES,
                E0,E1,E2,E3,E4,E5,E6,E7,ETOP,INSTR_REG,
                INSTR, TYPENAME;

PROG ::= IMPORTBL:imps DECBL:decs MAINBL:exe
    {: RESULT=is.program(imps,decs,exe); :}
		;

IMPORTBL ::= 
		| Import Id:i From Id:s Punto IMPORTBL:r
    {: RESULT=is.imports(i,s,r); :}
		| Import Mul From Id:s Punto IMPORTBL:r
    {: RESULT=is.imports(null,s,r); :}
    | Import error Punto
		;

DECBL ::= 
		| DEC_VAR:v DECBL:r
    {: RESULT=is.declares(v,r,Dec.VAR); :}
		| DEC_REG:v DECBL:r 
    {: RESULT=is.declares(v,r,Dec.REGISTER); :}
		| DEC_DEFREG:v DECBL:r
    {: RESULT=is.declares(v,r,Dec.DEFREG); :}
		| DEC_FUN:v DECBL:r
    {: RESULT=is.declares(v,r,Dec.FUNCTION); :}
		| DEC_TYPE:v DECBL:r 
    {: RESULT=is.declares(v,r,Dec.TYPE); :}
		;

DEC_VAR ::= Const TYPENAME:t Id:i Asign EXPR:e Punto
    {: RESULT=is.dec_var(t,i,e,true); :}
		| TYPENAME:t Id:i Asign EXPR:e Punto
    {: RESULT=is.dec_var(t,i,e,false); :}
		;

DEC_REG ::= TYPENAME:t Id:i PA VALUES:v PC Punto
    {: RESULT=is.dec_reg(t,i,v); :}
		;

DEC_DEFREG ::= Data Id:i PA CPARAMS:ps PC Asign LA DENTRO_REG:d LC Punto 
    {: RESULT=is.dec_defreg(i,ps,d); :}
		;
CPARAMS ::= 
		| Const TYPENAME:t Id:i
    {: RESULT=is.params(t,i,null,true); :}
		| Const TYPENAME:t Id:i Coma CPARAMS:r
    {: RESULT=is.params(t,i,r,true); :}
		;
DENTRO_REG ::= 
		| INSTR_REG:d DENTRO_REG :r
    {: RESULT=is.instructions(d,r); :}
		;
DEC_TYPE ::= Type Id:i Asign TYPENAME:t Punto
    {: RESULT=is.dec_type(i,t); :}
		;

DEC_FUN ::= Function Id:i Return TYPENAME:t PA PARAMS:ps PC LA DENTRO:d LC 
    {: RESULT=is.dec_fun(i,t,ps,d); :}
		;
PARAMS ::= CPARAMS:c
    {: RESULT=c; :}
		| TYPENAME:t Id:i
    {: RESULT=is.params(t,i,null,false); :}
		| TYPENAME:t Id:i Coma PARAMS :r
    {: RESULT=is.params(t,i,r,false); :}
		| error
		;
DENTRO ::= 
		| INSTR:i DENTRO:r
    {: RESULT=is.instructions(i,r); :}
		;


MAINBL ::= Main LA DENTRO:d LC 
    {: RESULT=d; :}
		;

EXPR ::= E0:o
    {: RESULT=o; :}
		;
E7 ::= E7:o1 Acceso ETOP:o2
    {: RESULT=as.op_acceso(o1,o2,Op.ACCESO); :}
        | ETOP:o
    {: RESULT=o; :}
		;
E6 ::= E6:o1 Indice E7:o2
    {: RESULT=as.op_indice(o1,o2,Op.INDICE); :}
        | E7:o
    {: RESULT=o; :}
		;
E5 ::= Guion E6:o
    {: RESULT=as.op_mono(o,Op.SIGNO); :}
        | E6:o
    {: RESULT=o; :}
		;
E4 ::= E4:o1 Mod E5:o2
    {: RESULT=as.op_bin(o1,o2,Op.MOD); :}
        | E4:o1 Div E5:o2
    {: RESULT=as.op_bin(o1,o2,Op.DIV); :}
        | E4:o1 Mul E5:o2
    {: RESULT=as.op_bin(o1,o2,Op.MUL); :}
        | E5:o
    {: RESULT=o; :}
		;
E3 ::= E3:o1 Suma E4:o2
    {: RESULT=as.op_bin(o1,o2,Op.SUMA); :}
        | E3:o1 Guion E4:o2
    {: RESULT=as.op_bin(o1,o2,Op.RESTA); :}
        | Not E4:o
    {: RESULT=as.op_mono(o,Op.NOT); :}
        | E4:o
    {: RESULT=o; :}
		;
E2 ::= E2:o1 Meq E3:o2
    {: RESULT=as.op_bin(o1,o2,Op.MEQ); :}
        | E2:o1 Maq E3:o2
    {: RESULT=as.op_bin(o1,o2,Op.MAQ); :}
        | E2:o1 Menor E3:o2
    {: RESULT=as.op_bin(o1,o2,Op.MENOR); :}
        | E2:o1 Mayor E3:o2
    {: RESULT=as.op_bin(o1,o2,Op.MAYOR); :}
        | E2:o1 And E3:o2
    {: RESULT=as.op_bin(o1,o2,Op.AND); :}
        | E3:o 
    {: RESULT=o; :}
		;
E1 ::= E1:o1 Or E2:o2
    {: RESULT=as.op_bin(o1,o2,Op.OR); :}
        | E2:o
    {: RESULT=o; :}
		;
E0 ::= E0:o1 Igual E1:o2
    {: RESULT=as.op_bin(o1,o2,Op.IGUAL); :}
        | E0:o1 Distinto E1:o2
    {: RESULT=as.op_bin(o1,o2,Op.DISTINTO); :}
        | E1:o
    {: RESULT=o; :}
		;
ETOP ::= Entero:e
    {: RESULT=as.op_basico_ent(e); :}
        | Si :e
    {: RESULT=as.op_basico_bul(e); :}
        | No :e
    {: RESULT=as.op_basico_bul(e); :}
        | Id :e
    {: RESULT=as.op_basico_id(e); :}
        | Caracter :e
    {: RESULT=as.op_basico_car(e); :}
        | PA E0:e PC
    {: RESULT=e; :}
        | EXPFUN:e
    {: RESULT=e; :}
        | EXPLISTA:e
    {: RESULT=e; :}
        | PA EXPR:e1 Coma EXPR:e2 PC
    {: RESULT=as.op_bin(e1,e2,Op.ARRAYINIT); :}
        ;

EXPFUN ::= Id:i PA VALUES:v PC
    {: RESULT=as.op_call(i,v); :};
EXPLISTA ::= CA LISTADENTRO:l CC
    {: RESULT=as.op_listinit(l); :};
LISTADENTRO ::= 
        | EXPR:e
    {: RESULT=as.list_cons(e,null); :}
        | EXPR:e Coma LISTADENTRO:l
    {: RESULT=as.list_cons(e,l); :}
        ;
		
		
INSTR_REG ::= DEC_VAR:i
    {: RESULT=i; :}
		| DEC_REG :i
    {: RESULT=i; :}
        ;
    
INSTR ::= INSTR_REG:i
    {: RESULT=i; :}
		| EXPR:e1 Asign EXPR:e2 Punto
    {: RESULT=is.ins_asign(e1,e2); :}
		| Return EXPR:e Punto
    {: RESULT=is.ins_return(e); :}
		| Kut PA EXPR:e PC Punto
    {: RESULT=is.ins_kut(e); :}
		| While PA EXPR:b PC LA DENTRO:d LC
    {: RESULT=is.ins_while(b,d); :}
		| For PA Id:el DosPts EXPR:ar PC LA DENTRO:d LC
    {: RESULT=is.ins_for(el,ar,d); :}
		| If PA EXPR:b PC LA DENTRO:d LC
    {: RESULT=is.ins_if(b,d); :}
		| If PA EXPR:b PC LA DENTRO:d1 LC Else LA DENTRO:d2 LC
    {: RESULT=is.ins_ifelse(b,d1,d2); :}
		| EXPFUN:f Punto
    {: RESULT=is.ins_fun(f); :}
        | error Punto
		;

VALUES ::= 
		| EXPR:e
    {: RESULT=is.values(e,null); :}
		| EXPR:e Coma VALUES:v
    {: RESULT=is.values(e,v); :}
		;
TYPENAME ::= Ent:e
    {: RESULT=is.typename(e); :}
        | Bul :e
    {: RESULT=is.typename(e); :}
        | Car :e
    {: RESULT=is.typename(e); :}
        | Id :e
    {: RESULT=is.typename(e); :}
        | Arr Backslash TYPENAME:e
    {: RESULT=is.typename_arr(e); :}
        ;










